#!perl

use 5.010;
use strict;
use warnings;
use FindBin '$Bin';
use lib "$Bin/lib";

use Test::More 0.96;

use File::chdir;
use File::Temp qw(tempdir);
use Perinci::Access::InProcess;
use Perinci::Tx::Manager;
use Scalar::Util qw(blessed);

# yeah, symlink() is not really necessary, but at the time of writing this
# test script, only Setup::File::Symlink has been converted to use
# Riap::Transaction.
plan skip_all => "symlink() not available"
    unless eval { symlink "", ""; 1 };

test_request(
    name => 'must be activated with use_tx',
    req => [begin_tx=>"/", {tx_id=>"tx1"}],
    status => 501,
);

my $tm;
my $tmp_dir = tempdir(CLEANUP=>1);
$CWD = $tmp_dir;
my $tx_dir  = "$tmp_dir/.tx";
diag "tx dir is $tx_dir";
my $pa_cached = Perinci::Access::InProcess->new(
    use_tx=>1,
    custom_tx_manager => sub {
        my $self = shift;
        $tm //= Perinci::Tx::Manager->new(
            data_dir => $tx_dir, pa => $self);
        die $tm unless blessed($tm);
        $tm;
    });

subtest 'request to unknown tx = fail' => sub {
    test_request(
        req => [call=>"/Setup/File/Symlink/setup_symlink",
                {tx_id=>"unknown1",
                 args=>{symlink=>"$tmp_dir/s1", target=>"t1"}}],
        status => 484,
    );
};

subtest 'successful transaction' => sub {
    test_request(
        req => [begin_tx=>"/", {tx_id=>"s1"}],
        status => 200,
        posttest => sub {
            my $tres = $tm->list(detail=>1);
            is($tres->[0], 200, "txm->list() success");
            is(scalar(@{$tres->[2]}), 1, "There is 1 transaction");
            is($tres->[2][0]{tx_status}, "i", "Transaction status is i");
        },
    );
    test_request(
        req => [call=>"/Setup/File/Symlink/setup_symlink",
                {tx_id=>"s1",
                 args=>{symlink=>"$tmp_dir/s1-l1", target=>"t1"}}],
        status => 200,
        posttest => sub {
            my ($res) = @_;
            my $tres = $tm->list(detail=>1, tx_id=>"s1");
            is($tres->[2][0]{tx_status}, "i", "Transaction status is i");

            ok(!$res->[3]{undo_data},
               "undo_data result metadata is suppressed");
        },
    );
    test_request(
        req => [call=>"/Setup/File/Symlink/setup_symlink",
                {tx_id=>"s1",
                 args=>{symlink=>"$tmp_dir/s1-l2", target=>"t1"}}],
        status => 200,
        posttest => sub {
            my $tres = $tm->list(detail=>1, tx_id=>"s1");
            is($tres->[2][0]{tx_status}, "i", "Transaction status is i");
        },
    );
    test_request(
        req => [commit_tx=>"/", {tx_id=>"s1"}],
        status => 200,
        posttest => sub {
            my $tres = $tm->list(detail=>1, tx_id=>"s1");
            is($tres->[2][0]{tx_status}, "C", "Transaction status is C");

            ok((-l "$tmp_dir/s1-l1"), "final state of s1 (l1) = done");
            ok((-l "$tmp_dir/s1-l2"), "final state of s1 (l2) = done");
        },
    );
};
# txs: s1(C)

subtest 'cannot begin transaction with the same name as existing (C)' => sub {
    test_request(
        req => [begin_tx=>"/", {tx_id=>"s1"}],
        status => 409,
        posttest => sub {
            my $tres = $tm->list(detail=>1, tx_id=>"s1");
            is($tres->[2][0]{tx_status}, "C", "Transaction status is C");
        },
    );
};

subtest 'cannot begin transaction with the same name as existing (i)' => sub {
    test_request(
        req => [begin_tx=>"/" , {tx_id=>"s1b1"}],
        status => 200,
    );
    test_request(
        req => [begin_tx=>"/" , {tx_id=>"s1b1"}],
        status => 409,
        posttest => sub {
            my $tres = $tm->list(detail=>1, tx_id=>"s1b1");
            is($tres->[2][0]{tx_status}, "i", "Transaction status is i");
        },
    );
    test_request(
        req => [rollback_tx=>"/" , {tx_id=>"s1b1"}],
        status => 200,
    );
    test_request(
        req => [discard_tx=>"/" , {tx_id=>"s1b1"}],
        status => 200,
    );
};

subtest 'failed invocation = rolls back' => sub {
    test_request(
        req => [begin_tx=>"/", {tx_id=>"f1"}],
        status => 200,
    );
    test_request(
        req => [call=>"/Setup/File/Symlink/setup_symlink",
                {tx_id=>"f1", args=>{}}],
        status => 400,
        posttest => sub {
            my $tres = $tm->list(detail=>1, tx_id=>"f1");
            is($tres->[2][0]{tx_status}, "R", "Transaction status is R");
        },
    );
};
# txs: s1(C), f1(R)

subtest 'other qualified functions: pure, dry_run' => sub {
    test_request(
        req => [begin_tx=>"/", {tx_id=>"s2"}],
        status => 200,
    );
    test_request(
        name => 'pure',
        req => [call=>"/Perinci/Examples/noop",
                {tx_id=>"f2", args=>{}}],
        status => 200,
    );
    test_request(
        name => 'dry_run',
        req => [call=>"/Setup/File/Symlink/setup_symlink",
                {tx_id=>"s2",
                 args=>{symlink=>"$tmp_dir/s2-l1",
                        target=>"t1", -dry_run=>1}}],
        status => 200,
    );
    test_request(
        req => [commit_tx=>"/",
                {tx_id=>"s2"}],
        status => 200,
        posttest => sub {
            my $tres = $tm->list(detail=>1, tx_id=>"s2");
            is($tres->[2][0]{tx_status}, "C", "Transaction status is C");
        },
    );
};
# txs: s1(C), f1(R), s2(C)

subtest 'invoking unqualified function = rolls back' => sub {
    test_request(
        req => [begin_tx=>"/", {tx_id=>"f2"}],
        status => 200,
    );
    test_request(
        req => [call=>"/Perinci/Examples/delay",
                {tx_id=>"f2", args=>{n=>0}}],
        status => 412,
        posttest => sub {
            my $tres = $tm->list(detail=>1, tx_id=>"f2");
            is($tres->[2][0]{tx_status}, "R", "Transaction status is R");
        },
    );
};
# txs: s1(C), f1(R), s2(C), f2(R)

subtest 'rollback' => sub {
    test_request(
        req => [begin_tx=>"/", {tx_id=>"r1"}],
        status => 200,
    );
    test_request(
        req => [call=>"/Setup/File/Symlink/setup_symlink",
                {tx_id=>"r1",
                 args=>{symlink=>"$tmp_dir/r1-l1", target=>"t1"}}],
        status => 200,
    );
    test_request(
        req => [call=>"/Setup/File/Symlink/setup_symlink",
                {tx_id=>"r1",
                 args=>{symlink=>"$tmp_dir/r1-l2", target=>"t1"}}],
        status => 200,
    );
    test_request(
        req => [call=>"/Setup/File/Symlink/setup_symlink",
                {args=>{-undo_trash_dir=>"$tmp_dir/.tx/.trash",
                        symlink=>"$tmp_dir/r1-l3", target=>"t1"}}],
        status => 200,
    );
    test_request(
        req => [rollback_tx=>"/", {tx_id=>"r1"}],
        status => 200,
        posttest => sub {
            my $tres = $tm->list(detail=>1, tx_id=>"r1");
            is($tres->[2][0]{tx_status}, "R", "Transaction status is R");

            ok(!(-l "$tmp_dir/r1-l1"), "final state of r1 (l1) = undone");
            ok(!(-l "$tmp_dir/r1-l2"), "final state of r1 (l2) = undone");

            # call without tx_id is outside of tx
            ok((-l "$tmp_dir/r1-l3"),
               "final state of r1 (l3) = done (outside tx)");
        },
    );
};
# txs: s1(C), f1(R), s2(C), f2(R), r1(R)

subtest 'list_txs' => sub {
    test_request(
        name => 'detail=0',
        req => [list_txs=>"/", {}],
        status => 200,
        posttest => sub {
            my ($res) = @_;
            is(scalar(@{$res->[2]}), 5, "num");
            ok(!ref($res->[2][0]), "no detail");
        },
    );
    test_request(
        name => 'tx_id',
        req => [list_txs=>"/", {tx_id=>'s1'}],
        status => 200,
        posttest => sub {
            my ($res) = @_;
            is(scalar(@{$res->[2]}), 1, "num");
        },
    );
    test_request(
        name => 'tx_status',
        req => [list_txs=>"/", {tx_status=>'R'}],
        status => 200,
        posttest => sub {
            my ($res) = @_;
            is(scalar(@{$res->[2]}), 3, "num");
        },
    );
};

subtest 'cannot rollback transactions with status C' => sub {
    test_request(
        req => [rollback_tx=>"/", {tx_id=>"s1"}],
        status => 480,
        posttest => sub {
            my $tres = $tm->list(detail=>1, tx_id=>"s1");
            is($tres->[2][0]{tx_status}, "C", "Transaction status is C");

            ok((-l "$tmp_dir/s1-l1"), "final state of s1 (l1) = done");
            ok((-l "$tmp_dir/s1-l2"), "final state of s1 (l2) = done");
        },
    );
};
subtest 'cannot rollback transactions with status R' => sub {
    test_request(
        req => [rollback_tx=>"/", {tx_id=>"r1"}],
        status => 480,
        posttest => sub {
            my $tres = $tm->list(detail=>1, tx_id=>"r1");
            is($tres->[2][0]{tx_status}, "R", "Transaction status is R");

            ok(!(-l "$tmp_dir/r1-l1"), "final state of r1 (l1) = undone");
            ok(!(-l "$tmp_dir/r1-l2"), "final state of r1 (l2) = undone");
        },
    );
};

# TODO cannot rollback transactions with status U, X

subtest 'undo' => sub {
    test_request(
        req => [undo=>"/", {tx_id=>"s1"}],
        status => 200,
        posttest => sub {
            my $tres = $tm->list(detail=>1, tx_id=>"s1");
            is($tres->[2][0]{tx_status}, "U", "Transaction status is U");

            ok(!(-l "$tmp_dir/s1-l1"), "final state of s1 (l1) = undone");
            ok(!(-l "$tmp_dir/s1-l2"), "final state of s1 (l2) = undone");
        },
    );
};
# txs: s1(U), f1(R), s2(C), f2(R), r1(R)

# TODO cannot undo transactions in states i, U, X, R, ...

subtest 'redo' => sub {
    test_request(
        req => [redo=>"/", {tx_id=>"s1"}],
        status => 200,
        posttest => sub {
            my $tres = $tm->list(detail=>1, tx_id=>"s1");
            is($tres->[2][0]{tx_status}, "C", "Transaction status is C");

            ok((-l "$tmp_dir/s1-l1"), "final state of s1 (l1) = done");
            ok((-l "$tmp_dir/s1-l2"), "final state of s1 (l2) = done");
        },
    );
};
# txs: s1(C), f1(R), s2(C), f2(R), r1(R)

# TODO cannot redo transactions in states i, C, X, R, ...

subtest 'discard_tx' => sub {
    test_request(
        req => [discard_tx=>"/", {tx_id=>"s1"}],
        status => 200,
        posttest => sub {
            my $tres = $tm->list(tx_status=>"C");
            is(scalar(@{$tres->[2]}), 1, "num C = 1");
            $tres = $tm->list(tx_id=>"s1");
            is(scalar(@{$tres->[2]}), 0, "tx s1 is gone");

            # discarding does not effect transaction result
            ok((-l "$tmp_dir/s1-l1"), "final state of s1 (l1) = done");
            ok((-l "$tmp_dir/s1-l2"), "final state of s1 (l2) = done");
        },
    );
};
# txs: f1(R), s2(C), f2(R), r1(R)

# TODO test cannot discard transactions in states i, ...

subtest 'discard_all_txs' => sub {
    # commit some txs first
    test_request(req => [begin_tx=>"/" , {tx_id=>"sd1"}], status => 200);
    test_request(req => [commit_tx=>"/", {tx_id=>"sd1"}], status => 200);
    test_request(req => [begin_tx=>"/" , {tx_id=>"sd2"}], status => 200);
    test_request(req => [commit_tx=>"/", {tx_id=>"sd2"}], status => 200);
    test_request(req => [undo=>"/"     , {tx_id=>"sd2"}], status => 200);
    test_request(req => [begin_tx=>"/" , {tx_id=>"sd3"}], status => 200);
    test_request(
        req => [commit_tx=>"/", {tx_id=>"sd3"}], status => 200,
        posttest => sub {
            my $tres = $tm->list(tx_status=>"C");
            is(scalar(@{$tres->[2]}), 3, "num C = 3");
            $tres = $tm->list(tx_status=>"U");
            is(scalar(@{$tres->[2]}), 1, "num U = 1");
        }
    );
    # TODO test discard transactions in state X
    test_request(
        req => [discard_all_txs=>"/"],
        status => 200,
        posttest => sub {
            my $tres = $tm->list(tx_status=>"C");
            is(scalar(@{$tres->[2]}), 0, "num C = 0");
            $tres = $tm->list(tx_status=>"U");
            is(scalar(@{$tres->[2]}), 0, "num U = 0");
        },
    );
};
# txs: f1(R), f2(R), r1(R)

subtest 'nested_call' => sub {
    my $txid = "n1";
    test_request(req => [begin_tx=>"/" , {tx_id=>$txid}], status => 200);
    test_request(
        req => [call=>"/TestNested/setup_two_symlinks",
                {args=>{symlink1=>"$tmp_dir/$txid-l1", target1=>"t1",
                        symlink2=>"$tmp_dir/$txid-l2", target2=>"t2",},
                 tx_id=>$txid}],
        status => 200,
    );
    test_request(
        req => [commit_tx=>"/", {tx_id=>$txid}],
        status => 200,
        posttest => sub {
            my $tres = $tm->list(detail=>1, tx_id=>$txid);
            is($tres->[2][0]{tx_status}, "C", "Transaction status is C");

            ok((-l "$tmp_dir/$txid-l1"),"final state of $txid(l1) = done");
            ok((-l "$tmp_dir/$txid-l2"),"final state of $txid(l2) = done");
        },
    );
    test_request(
        req => [undo=>"/", {tx_id=>$txid}],
        status => 200,
        posttest => sub {
            my $tres = $tm->list(detail=>1, tx_id=>$txid);
            is($tres->[2][0]{tx_status}, "U", "Transaction status is U");

            ok(!(-l "$tmp_dir/$txid-l1"),"final state of $txid(l1)=undone");
            ok(!(-l "$tmp_dir/$txid-l2"),"final state of $txid(l2)=undone");
        },
    );
    test_request(
        req => [redo=>"/", {tx_id=>$txid}],
        status => 200,
        posttest => sub {
            my $tres = $tm->list(detail=>1, tx_id=>$txid);
            is($tres->[2][0]{tx_status}, "C", "Transaction status is C");

            ok((-l "$tmp_dir/$txid-l1"),"final state of $txid(l1) = done");
            ok((-l "$tmp_dir/$txid-l2"),"final state of $txid(l2) = done");
        },
    );
    test_request(
        req => [undo=>"/", {tx_id=>$txid}],
        status => 200,
        posttest => sub {
            my $tres = $tm->list(detail=>1, tx_id=>$txid);
            is($tres->[2][0]{tx_status}, "U", "Transaction status is U");

            ok(!(-l "$tmp_dir/$txid-l1"),"final state of $txid(l1)=undone");
            ok(!(-l "$tmp_dir/$txid-l2"),"final state of $txid(l2)=undone");
        },
    );
};
# txs: f1(R), f2(R), r1(R), n1(U)

# TODO in-progress transaction cannot be discarded

# TODO test two transactions in parallel (one client)

# TODO test failed rollback (tx status becomes X)
# TODO test failed rollback (tx status becomes X)
# TODO test failed rollback (tx status becomes X)

# TODO test crash during calls and recovery
# TODO test crash during undoing and recovery
# TODO test crash during redoing and recovery
# TODO test crash during rollback and recovery

DONE_TESTING:
done_testing();
if (Test::More->builder->is_passing) {
    #diag "all tests successful, deleting test data dir";
    $CWD = "/" unless $ENV{NO_CLEANUP};
} else {
    diag "there are failing tests, not deleting tx dir";
}

sub test_request {
    my %args = @_;
    my $req = $args{req};
    my $test_name = ($args{name} // "") . " (req: $req->[0] $req->[1])";
    subtest $test_name => sub {
        my $pa;
        if ($args{object_opts}) {
            $pa = Perinci::Access::InProcess->new(%{$args{object_opts}});
        } else {
            unless ($pa_cached) {
                $pa_cached = Perinci::Access::InProcess->new;
            }
            $pa = $pa_cached;
        }
        my $res = $pa->request(@$req);
        if ($args{status}) {
            is($res->[0], $args{status}, "status")
                or diag explain $res;
        }
        if (exists $args{result}) {
            is_deeply($res->[2], $args{result}, "result")
                or diag explain $res;
        }
        if ($args{posttest}) {
            $args{posttest}($res);
        }
        done_testing();
    };
}
